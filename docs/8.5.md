# 栈的压入弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

## 思路

借助一个辅助栈来模拟压入、弹出的过程。
设置一个索引idx，记录popV（出栈序列）栈顶的位置
将pushV中的数据依次入栈。
在压入后的同时判断辅助栈栈顶的元素是否和popV栈顶的元素相同，如果相同，那么让辅助栈出栈，每次出栈 索引idx+1。

> 如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。
> 如果下一个弹出的数字不再栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个应该出栈的元素压入栈顶
> 如果所有的数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列

当所有数据入栈完成，如果出栈顺序正确，那么辅助栈应该为空。

要注意一点的是idx栈顶是0不是length-1

## 代码

```js
function IsPopOrder(pushV, popV)
{
	if(!pushV||!popV||pushV.length == 0 || popV.length == 0){
		return ;
	}
	var stack=[];
	var idx=0;
	for(var i=0;i<pushV.length;i++){
	   stack.push(pushV[i]);
	   while(stack.length!==0&&stack[stack.length-1]===popV[idx]){
		   stack.pop();
		   idx++;
	   }
	}
	return stack.length===0;
}
```